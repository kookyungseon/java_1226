Day20 

Wrapper class
기본 자료형들의 클래스 타입

기본타입(원시 타입)		Wrapper 클래스
	int			Integer
	long			Long
	double		Double
	float			Float
	boolean		Boolean
	char			Charater

자료형 변수명 = 값;
클래스명 참조변수명 = new 생성자 ( );

클래스타입 변수 = new 클래스타입(일반타입의 값); //boxing
클래스타입 변수 = 클래스타입.valueOf(일반타입의 값);//
일반타입 변수 = 객체. 타입Value; //unboxing


boxing : 기본타입의 값을 wrapper 클래스의 객체로 변환
unboxing : wrapper 클래스 객체에서 기본타입의 값으로 변환

JDK4버전 이상 부터는 auto boxing과 auto unboxing을 지원한다
클래스타입 객체 = 일반타입의 값; //auto boxing
일반타입 변수 = 객체;     //auto unboxing

Wrapper Class를 사용하는 이유
원시타입(기본타입)을 박싱하면 다양한 메소드를 제공받을 수 있다
여러 기본 타입을 하나의 타입으로 묶기 위해서는 반드시 클래스 타입(Wrapper Class)
으로 사용해야되고 이때는 방식을 해줘야한다.
- 클래스 타입은 다양한 메소드 제공 받을 수 있다
- 자바에서는 클래스 타입이 갖는 이점이 많다
	ex) api에서 제공하는 여러 메소드는 매개변수로 클래스타입(Object)
	     기본자료형을 넘겨 줄 수 없으므로 박싱을 해줘야 한다 

컬렉션 프레임워크(Collection Framework)

1.알고리즘과 자료구조
	사전에 단어 찾기
	java => a~Z 사전의 첫페이지부터 끝까지 찾는 방법
		 사전은 알파벳 순서대로 정렬되어 있음을 알고 찾는 방법
		 		
	알고리즘 : 어떤 문제가 발생되었을 때 해결할 수 있는 순서 혹은 절차
	자료구조 : 의미 없는 데이터를 하나의 정보로 만들어주는 알고리즘의 집합
		   수집한 자료를 저장하는 방법 

2. 컬렉션 프레임워크(Collection Framework) : 자료구조
	많은 데이터를 쉽고 효과적으로 관리 할 수 있는 표준화된 방법을
	제공하는 클래스들의 집합
	List
	Set
	Map

List(인터페이스) extends Collection
	데이터의 순서를 보장한다 
	중복된 값을 허용한다 
	
List 구현 클래스
	Vector : 용량관리, 보안성 강화, 처리량 감소 
	LinkedList : 추가 , 삭제는 빠르지만 검색(탐색)이 상대적으로 느리다 
	ArrayList : 배열과 동일하게 인덱스로 데이터를 관리한다 
		추가, 삭제가 상대적으로 느리지만 검색(탐색)이 빠르다 

<E> : Element 제네릭
	타입 안정성을 보장하기 위한 기능
	결정되지 않은 타입을 파라미터 (매개변수)로 처리하고 실제 사용할 때 
	파라미터(매개변수)를 구체적인 타입으로 대체시키는게 가능

제네릭을 사용하는 이유
	1) 제네릭을 사용하지 않는다면 요소의 타입별로 클래스를 만들어야 한다 .
	2) 제네릭 대신 Object 타입을 사용한다면 다운캐스팅을 해야한다
	3) 제네릭은 타입을 제한할 수 있다. (Object 타입은 모든 타입을 다 받는다)

Set : 집합
	데이터의 순서를 보장하지 않는다
	데이터의 중복을 허용하지 않는다 
	
구현 클래스 
HashSet
	Set 인터페이스를 구현한 대표적인 클래스 
	중복되는 값을 저장하면 무시한다
	인덱스가 존재하지 않아 순서를 보장하지 않으며 ArrayList나 배열처럼
	갓을 가져오는 것이 불가능하다
	HashCode()가 반환하는 해시코드를 이용해서 데이터를 처리하며 속도가 빠르다 


Iterator
	컬렉션에서 저장된 데이터들을 컬렉션의 종류와 상관없이 동일한 방식으로 
	가져오기 위한 인터페이스(타입)
	어떤 자료구조든 Iterator로 변환하면 Iterator만의 방식으로 
	순서를 만들고 값을 가져올 수 있다.
	값의 유무를 검사하거나 값을 가져올 때는 커서를 이용한다
	
	iterator()
		ArrayList, HashSet등의 컬렉션 객체를 Iterator 타입으로 
		변활할 때 사용하는 메소드
	hashNext()
		다음값의 유무를 검사하여 boolean 타입으로 반환한다
	next()
		다음값을 가져온다. 아무값도 없으면 예외가 발생한다
		NoSuchElementException


Map
	데이터의 순서를 보장하지 않는다
	데이터를 key와 value 한쌍으로 저장하여 key로 데이터를 접근할 수 있다 .
	그러므로 key는 ArrayList의 index와 비슷한 역할을 하며 중복을 허용하지 않는다.
	key는 중복허용 x, value는 중복 허용
	
구현 클래스 HashMap
	hashCode()가 반환하는 해시코드를 이용하며 검색 속도가 빠르다 
	이미 저장된 key를 가진 한쌍 데이터를 넣으면 가장 마지막에 넣은 value로 수정이된다 
	(Value는 수정이 가능하다)
	저장되지 않는 key를 가진 한 쌍의 데이터를 넣으면 새롭게 추가된다.


































