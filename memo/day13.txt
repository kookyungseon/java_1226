Day03

0. 복습
접근 제한자 ( 제어자 )
변수, 메소드, 클래스의 접근 권한을 제어하는 것

default : 다른 패키지에서 접근 불가
(별도로 명시하지 않고 접근 제한자 생략시 자동으로 default)
public : 같은 프로젝트 안에만 있으면 접근 가능
protected : 다른 패키지에서 접근 불가, 자식 클래스에서만 접근 가능
private : 다른 클래스에서 접근 불가, 같은 클래스만 접근 가능 
	= > getter, setter 메소드를 사용하면 다른 클래스에서 접근 가능
	사용자에게 내부 원리는 감추고 사용법만 외부로 노출시키는 것
	(캡슐화, 은닉화)

Casting

Up casting  : 자식의 값을 부모 타입으로 형변환. (자동 형변환)

Down casting : 이미 up casting된 값을 자식 타입으로 형변환 

Instancesf
a instanceof A : a가 A타입이면 true, 아니면 false

다형성 
하나의 것이 여러 가지 형태를 가질 수 있는 성질 
1) 오버로딩
	같은 클래스 내에서 생성자 또는 메소드를 같은 이름으로 
	매개변수의 타입이나 갯수만 다르게 만든다.
2) 오버라이딩
	부모 클래스에서 선언한 메소드를 자식 클래스에서 수정하고자 할때 
	부모 클래스와 동일한 이름으로 선언, 재정의 
3) 참조변수의 다형성(매개변수의 다형성)
	부모 클래스 타입의 참조변수로 자식클래스 객체를 가리키는 것을 허용

1. 추상클래스

추상 메소드
- 메소드를 선언하고 구현을 하지 않은 것을 추상 메소드라고 한다 . ( 미완성 메소드 )
- abstract 리턴타입 메소드명 ( 매게변수, … );
	1) abstract 키워드르 사용한다.
	2) 마지막에 세미콜론을 써야한다
추상 클래스 
- 추상 메소드가 한 개 이상 있는 클래스는 반드시 추상 클래스로 선언해야 한다.
- abstract 키워드가 붙은 클래스 

추상 클래스 선언
abstract class 클래스명 {
	abstract 리턴타입 메소드명(매개변수, …);
	* 일반 메소드도 선언 가능
}

1. abstract 키워드를 사용한다.
2. 객체화 시킬 수 없다.

*** 미완성 메소드(추상 메소드)는 상속받은 자식 클래스에서 반드시 재정의하여 구현해야만
자식 클래스를 객체화 할 수 있다 . 그러므로 [강제성]을 부여하기 위해서 추상 메소드로 선언한다.

추상 클래스를 사용하는 이유 
공통되는 속성과 행위를 추상화하여 부모클래스를 만드는데 모든 자식 클래스에서 
구현해야하는데 메소드가 있다면 추상메소드로 선언하는게 좋다.
충상 클래스를 상속받은 자식 클래스는 추상 메소드를 오버라이딩 하지 않으면 
오류가 발생하므로 [강제성]이 생기게 된다.
만약 부모클래스에서 메소드를 구현 한다면 강제성 없으므로 자식 클래스를 만드는 
개발자가 재정의하지 않고 그냥 넘어갈 수 있다. 

2. 인터페이스(interface)
일종의 추상 클래스이지만 클래스라고 부르지 않으며 추상화의 정도가 더 높다
멤버 상수와 추상메소드만 가질 수 있다.
인터페이스는 객체화 할 수 없으며, 다른 클래스에서 구현(implements)해서 사용한다.
(상속과 비슷하다)
구현할 때는 implements 키워드를 사용한다

인터페이스 선언
interface 인터페이스명{
	멤버 선언;
}

인터페이스의 멤버
1. 모든 필드 public static final 이 붙는다 (생략해도 자동으로 붙음)
2. 모든 메소드는 public abstract이 붙는다.(생략해도 자동으로 붙음)

클래스 상속과 인터페이스의 구현
1. 클래스는 단일 상속만 가능하며 인터페이스는 다중 구현 가능하다.
2. 상속과 구현은 별개이다. 
    즉, 하나의 클래스에 상속과 구현을 동시에 할 수 있다
3. 인터페이스는 다른 인터페이스를 상속(extends)할 수 있다 .

인터페이스를 사용하는 이유
1. 여러 클래스에서 선언할 멤버들을 일관되게 하기 위해 사용한다 (표준화)
2. 관계없는 클래스들을 그룹화 시킬 수 있다. (마커 인터페이스 )

인터페이스의 불편함
인터페이스는 강제성이 강하기 때문에 구현하는 클래스에서 일부만 재정의하여 사용하는게 
불가능하다.
이를 해결하기 위해 Adapter라는 추상 클래스를 사용한다. 

   모든 강제성        일부 강제성 
[인터페이스] -> [Adapter 클래스] ->  [클래스]
	      구현                         상속 

인터페이스의 강제성을 어댑터 클래스를 통해 없애주고 이 어댑터 클래스를 자식 클래스에서 
상속받아 필요한 메소드만 자식 클래스에서 재정의하여 사용한다.
어댑터 클래스의 이름은 이름뒤에 Adapter를 붙여서 목적을 알려준다.
 


 











